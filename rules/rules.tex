% \subsection{Rule 1 - Show an app chooser} 

% \textbf{Google Guideline.} \emph{If an implicit intent can launch at least two possible apps on a user's device, explicitly show an app chooser. This interaction strategy allows users to transfer sensitive information to an app that they trust.}

% \begin{lstlisting}[language=Java, caption=Show an app chooser, numbers=none]
%  Intent intent = new Intent(Intent.ACTION_SEND);
%  List<ResolveInfo> possibleActivitiesList = queryIntentActivities(intent, PackageManager.MATCH_ALL);

%  // Verify that an activity in at least two apps on 
%  // the user's device can handle the intent. 
%  // Otherwise, start the intent only if an app on 
%  // the user's device can handle the intent.
%  if (possibleActivitiesList.size() > 1) {

%    // Create intent to show chooser.
%    // Title is something similar to "Share this 
%    // photo with".

%    String title = getResources().getString(R.string.chooser_title);
%    Intent chooser = Intent.createChooser(intent, title);
%    startActivity(chooser);
%  } else if (intent.resolveActivity(
%    getPackageManager()) != null) {
%    startActivity(intent);
%  }

% \end{lstlisting}

% \textbf{Rule design.} The logic of Rule 1 is shown in Algorithm~\ref{algorithm1}, where we inspect all implicit intents used by an app, and verify that \texttt{Intent.createChooser()} is called on these intents. If an Intent is constructed as implicit, but \texttt{Intent.createChooser()} is not called on that intent, we mark it as a violation.

% \begin{algorithm}[]
% \SetAlgoLined
% \Begin{
% 	\texttt{implicitIntents} $\leftarrow$ getAppImplicitIntents()\\
%   	\texttt{chooserIntents} $\leftarrow$ getAppChooserIntents()\\
%   	\ForEach{\upshape \texttt{intent} \textbf{in} \texttt{implicitIntents}}{
%   	    \If{\upshape \texttt{intent} \textbf{not in} \texttt{chooserIntents}}{
%   	        \emph{Rule 1 is not respected.}
%   	    }
%   	}
% }
% \label{algorithm1}
% \caption{Show an app chooser}
% \end{algorithm}

% \textbf{Attack.} The attack aims at intercepting an implicit \texttt{Intent}, that is originally sent to a legitimate app, but that is intercepted by a malicious one without any user notification. To complete the attack, a malicious app exploits the implicit \texttt{Intent} forwarding system of the Android OS and the absence of an app chooser. Thus, by declaring the \texttt{Intent Filter} associated to the target implicit \texttt{Intent} with the highest priority, the malicious app becomes the recipient of the implicit \texttt{Intent}, which will be successfully delivered to the malicious app since no app chooser will be shown. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Rule 2 - Protect the access to Content Providers} 
% \subsubsection{Apply signature-based permissions}
% \textbf{Google guideline.} \emph{When sharing data between two apps that you control or own, use \textit{signature-based} permissions. These permissions don't require user confirmation and instead check that the apps accessing the data are signed using the same signing key. Therefore, these permissions offer a more streamlined, secure user experience.}

% \begin{lstlisting}[language=XML_android, caption=Apply signature-based permissions , numbers=none]
%  <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapp">
%    <permission 
%      android:name="my_custom_permission_name"
%      android:protectionLevel="signature" />
% \end{lstlisting}

% \subsubsection{Disallow access to your app's content providers}
% \textbf{Google guideline.} \emph{Unless you intend to send data from your app to a different app that you don't own, you should explicitly disallow other developers' apps from accessing the \texttt{ContentProvider} objects that your app contains. This setting is particularly important if your app can be installed on devices running Android 4.1.1 (API level 16) or lower, as the \texttt{android:exported} attribute of the \texttt{<provider>} element is \texttt{true} by default on those versions of Android.}
% \begin{lstlisting}[language=XML_android, caption=Disallow access to your app's content providers , numbers=none]
%  <manifest xmlns:android="http://schemas.android.com/apk/res/android" package="com.example.myapp">
%    <application ... >
%      <provider
%        android:name="android.support.v4.content.FileProvider"
%        android:authorities="com.example.myapp.fileprovider"
%        ...
%        android:exported="false">
%        <!-- Place child elements of <provider> here. -->
%      </provider>
%      ...
%    </application> 
%  </manifest>

% \end{lstlisting}

% \textbf{Rule design.} The logic of Rule 2 is shown in Algorithm~\ref{algorithm2}. We inspect the app manifest to obtain the list of exported \texttt{Content Providers}. If a declared Content Provider is exported, but is not protected by a custom permission, we warn the user.

% \setcounter{algocf}{1}
% \begin{algorithm}[]
% \SetAlgoLined
% \Begin{
% 	\texttt{providers} $\leftarrow$ getContentProviderObjs()\\
% 	\texttt{apiLevel} $\leftarrow$ getMinApiLevel()\\
% 	\ForEach{\upshape \texttt{provider} \textbf{in} \texttt{providers}}{
% 		\If{\upshape isExported(\texttt{provider}, \texttt{apiLevel})}{
% 		    \SetAlgoNoLine{\If{\upshape \textbf{not}     usesCustomPermission(\texttt{provider})}{
% 		        \emph{Rule 2 is not respected.}
% 		    }}
% 		}
% 	}
% }
% \caption{\change{Content provider access control}}
% \label{algorithm2}
% \end{algorithm}

% \textbf{Attack.} If a \texttt{ContentProvider} object is \textit{exported} and not permission-protected, any other app on the same device can interact with it, by launching SQL injection attacks, reading or modifying its data. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Rule 3 - Request only the needed permissions} 
% \label{ssec:rule3}
% \textbf{Google guideline.} \emph{Your app should request only the minimum number of permissions necessary to function properly. When possible, your app should relinquish some of these permissions when they're no longer needed.}

% \textbf{Rule design.} The logic of Rule 3 is shown in Algorithm~\ref{algorithm3}. We collect the list of permissions requested by an app from its manifest, and check if any of the APIs requiring such permissions are invoked by inspecting the app source code (for the mapping between APIs and permissions we rely on \textit{axplorer}\footnote{\url{https://github.com/reddr/axplorer}}). If a permission is requested, but not used, we consider it a vulnerability. 

% \begin{algorithm}[]
% \SetAlgoLined
% \Begin{
% 	\texttt{permissions} $\leftarrow$ getAllPermissions()\\
% 	\ForEach{\upshape \texttt{perm} \textbf{in} \texttt{permissions}}{
% 	    \texttt{sdkFuncs} $\leftarrow$ getSdkFuncs(\texttt{perm})\\
% 		\texttt{uriContProvs} $\leftarrow$ getURIContProvs(\texttt{perm})\\
% 		\texttt{names} $\leftarrow$ \texttt{sdkFuncs} + \texttt{uriContProvs}\\
% 		\texttt{called} $\leftarrow$ getCalledMethods(\texttt{names})\\
% 		\SetAlgoNoLine{
% 			\If{\upshape isEmpty(\texttt{called})}{
% 					\emph{Rule 3 is not respected.}   
% 				}		    
% 		    }
% 	}
% }
% \caption{\change{Provide the right permissions}}
% \label{algorithm3}
% \end{algorithm}

% \textbf{Attack.} To access protected resources on a mobile device, an app has to declare the associated permissions. Any code running within the same UID has access to the same set of protected resources, defined according to the permissions declared by the app. This can also happen for third-party libraries, which an app might include to have additional features. The higher the number of permissions declared by an app, the higher the risk for the whole mobile device to get attacked malicious code running within the same UID of that app. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \subsection{Rule 4 - Use intents to defer permissions} 
% \textbf{Google guideline.} \emph{Whenever possible, don't add a permission to your app to complete an action that could be completed in another app. Instead, use an intent to defer the request to a different app that already has the necessary permission.
% \\
% The following example shows how to use an intent to direct users to a contacts app instead of requesting the \texttt{READ\textunderscore CONTACTS} and \texttt{WRITE\textunderscore CONTACTS} permissions:}

% \begin{lstlisting}[language=Java, caption=Use intents to defer permissions, numbers=none]
%  // Delegates the responsibility of creating the
%  // contact to a contacts app, which has already
%  // been granted the appropriate WRITE_CONTACTS
%  // permission.
%  Intent insertContactIntent = new  Intent(Intent.ACTION_INSERT); 
%  insertContactIntent.setType(ContactsContract.Contacts.CONTENT_TYPE);

%  // Make sure that the user has a contacts app
%  // installed on their device.
%  if  (insertContactIntent.resolveActivity(getPackageManager()) != null) {
%    startActivity(insertContactIntent);
%  }

% \end{lstlisting}

% \emph{In addition, if your app needs to perform file-based I/O -- such as accessing storage or choosing a file -- it doesn't need special permissions because the system can complete the operations on your app's behalf. Better still, after a user selects content at a particular URI, the calling app is granted permission to the selected resource.}

% \textbf{Rule design.} The logic of Rule 4 is shown in Algorithm~\ref{algorithm4}. We get the list of permissions requested by the app from its manifest, and compare it with a ``\textit{blacklist}'' of permissions for the actions that could be completed by other apps (e.g. instead of requesting the \texttt{SEND\_SMS} permission, an app can delegate the action to the SMS app). If the app requests any of the blacklisted permissions, we consider it a violation to the rule. 

% \begin{algorithm}[]
% \SetAlgoLined
% \Begin{
% 	\texttt{permissions} $\leftarrow$ getAllPermissions()\\
%     \ForEach{\upshape \texttt{perm} \textbf{in} \texttt{permissions}}{
%      	   \SetAlgoNoLine{\If{\upshape \texttt{perm} \textbf{in} \texttt{blacklist}}{
% 				\emph{Rule 4 is not respected.}
%      	   }
%      	   }
%     }
% }
% \caption{Use intents to defer permissions}
% \label{algorithm4}
% \end{algorithm}

% \textbf{Attack.} The attack that can exploit the vulnerability detected by Rule 4 is the same as the one for Rule 3 in Section~\ref{ssec:rule3}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 5 - Use SSL traffic} 

\textbf{Google Guideline.} \emph{If your app communicates with a web server that has a certificate issued by a well-known, trusted CA, the HTTPS request is very simple: }

\begin{lstlisting}[language=Java, caption=Use SSL traffic, numbers=none]
 URL url = new URL("https://www.google.com");
 HttpsURLConnection urlConnection = (HttpsURLConnection) url.openConnection();
 urlConnection.connect();
 InputStream in = urlConnection.getInputStream();
\end{lstlisting}


\textbf{Rule design.} The logic of Rule 5 is shown in Algorithm~\ref{algorithm5}. 
We first search for invocations of the \texttt{URL.openConnection()} method. If the return value of such invocations is cast to \texttt{HttpURLConnection} and not to \texttt{HttpsURLConnection}, we consider it a violation. Additionally, we check if the connections have a \texttt{TrustManager} or handle the exceptions. 

\setcounter{algocf}{4}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{openConns} $\leftarrow$ getOpenConnVars()\\
	\texttt{httpsOpenConns} $\leftarrow$ getHttpsOpenConnVars()\\
	\texttt{httpsConnSSLs} $\leftarrow$ getConnSSLSockFactVars()\\
	\ForEach{\upshape \texttt{openConn} \textbf{in} \texttt{openConns}}{
	    \If{\upshape \texttt{openConn} \textbf{not in} \texttt{httpsOpenCons}}{
	        \emph{Rule 5 is not respected.}
	    }
	    \If{\upshape \texttt{openConn} \textbf{not in} \texttt{httpsConnSSLs} \\
	    \textbf{and not} catchesException(\texttt{openConn})}{
	        \emph{Rule 5 is not respected.} 
	    }
	}
}
\caption{\change{Use SSL traffic}}
\label{algorithm5}
\end{algorithm}

\textbf{Attack.} The \texttt{SSLSocketFactory} can be used to validate the identity of an HTTPS server against a list of trusted certificates and to authenticate to the HTTPS server using a private key.

If HTTPS is not used, or it is used without a validation of the HTTPS server through the \texttt{SSLSocketFactory}, a \textit{Man-in-the-Middle} attack can be performed, i.e., an attacker can secretly relay and alter the communication between two parties. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Rule 6 - Do not use WebView JavascriptInterface} 

\textbf{Google Guideline.} \emph{Because \texttt{WebView} consumes web content that can include HTML and Javascript, improper use can introduce common web security issues such as cross-site-scripting (Javascript injection). Android includes a number of mechanisms to reduce the scope of these potential issues by limiting the capability of \texttt{WebView} to the minimum functionality required by your application.
\\
If your application doesn't directly use Javascript within a \texttt{WebView}, do not call \texttt{setJavascriptEnabled()}. Some sample code uses this method, which you might repurpose in production application, so remove that method call if it's not required. By default, \texttt{WebView} does not execute Javascript, so cross-site-scripting is not possible.
\\
Use \texttt{addJavascriptInterface()} with particular care because it allows Javascript to invoke operations that are normally reserved for Android applications. If you use it, expose \texttt{addJavascriptInterface()} only to web pages from which all input is trustworthy. If untrusted input is allowed, untrusted Javascript may be able to invoke Android methods within your app. In general, we recommend exposing \texttt{addJavascriptInterface()} only to Javascript that is contained within your application APK.
\\
If your app must use Javascript interface support on devices running Android 6.0 (API level 23) and higher, use HTML message channels instead to communicate between a website and your app, as shown in the following code snippet:}

\begin{lstlisting}[language=Java, caption=Use HTML message channels, numbers=none]
 WebView myWebView = (WebView)  findViewById(R.id.webview);

 // messagePorts[0] and messagePorts[1] represent
 // the two ports. They are already tangled to each
 // other and have been started.
 WebMessagePort[] channel = myWebView.createWebMessageChannel();

 // Create handler for channel[0] to receive
 // messages.
 channel[0].setWebMessageCallback(new WebMessagePort.WebMessageCallback() {
   @Override
   public void onMessage(WebMessagePort port, WebMessage message) {
     Log.d(TAG, "On port " + port + ", received this message: " + message);
   }
 });

// Send a message from channel[1] to channel[0].
channel[1].postMessage(new WebMessage("My secure message"));
\end{lstlisting}

\textbf{Rule design.} The logic of Rule 6 is shown in Algorithm~\ref{algorithm6}. We check if the app calls any method to enable or evaluate JavaScript code inside a \texttt{WebView} object. 

\setcounter{algocf}{5}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{s1} $\leftarrow$ ``setJavascriptEnabled''\\
    \texttt{s2} $\leftarrow$ ``true''\\
    \texttt{arr} $\leftarrow$ [``evaluateJavascript'', ``addJavascriptInt-\\erface'']\\
    \texttt{methods} $\leftarrow$ getAllCalledMethods()\\
	\ForEach{\upshape \texttt{method} \textbf{in} \texttt{methods}}{
	    \SetAlgoNoLine{\If{\upshape \texttt{method} \textbf{in} \texttt{arr}}{
	     	\emph{Rule 6 is not respected.}
	    }
	    \If{\upshape \texttt{method} = \texttt{s1}}{
	     	\If{\upshape getSecondArg(\texttt{method}) = \texttt{s2}}{
	     	\emph{Rule 6 is not respected.}
	    }
	    }
	    }
	}
}
\caption{\change{Use HTML message channels}}
\label{algorithm6}
\end{algorithm}

\textbf{Attack.} An insecure handling of Javascript code can lead to \gls{XSS} attacks. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Rule 7 - Use WebView objects carefully} 
\textbf{Google guideline.} \emph{Whenever possible, load only whitelisted content in \texttt{WebView} objects. In other words, the \texttt{WebView} objects in your app shouldn't allow users to navigate to sites that are outside of your control.}
\textbf{Rule design.} The logic of Rule 7 is shown in Algorithm~\ref{algorithm7}. Developers can use a custom \texttt{WebViewClient} to check the URLs that a \texttt{WebView} loads. We find violations to Rule 7 by checking if an app has any \texttt{WebView} object that does not use a custom \texttt{WebViewClient} to check the loaded URLs. 

\setcounter{algocf}{6}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{webViews} $\leftarrow$ getAllWebViewVars()\
	\texttt{whitelistedViews} $\leftarrow$ getSetWebViewClient()\
	\ForEach{\upshape \texttt{view} \textbf{in} \texttt{webViews}}{
	    \SetAlgoNoLine\If{\upshape \texttt{view} \textbf{not in} \texttt{whitelistedViews} \textbf{or not} isOverridingUrlLoading(\texttt{view})}{
	        \emph{Rule 7 is not respected.}
	    }
	}
}
\caption{\change{Use WebView objects carefully}}
\label{algorithm7}
\end{algorithm}

\textbf{Attack.} \texttt{WebView} objects are responsible for rendering the web code either belonging to external resources (e.g., a website) or saved in an app. If a \texttt{WebView} object loads any website and does not refer to a specific whitelist, an attacker might make the \texttt{WebView} object load a malicious website, which has JavaScript code running on the client side and able to steal sensitive information (e.g., cookies). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 8 - Store private data within internal storage} 
\textbf{Google guideline.} \emph{ Store all private user data within the device's internal storage, which is sandboxed per app. Your app doesn't need to request permission to view these files, and other apps cannot access the files. As an added security measure, when the user uninstalls an app, the device deletes all files that the app saved within internal storage.
\\
The following code snippet demonstrates one way to write data to storage:}
\begin{lstlisting}[language=Java, caption=Write data to the internal storage, numbers=none]
 // Creates a file with this name, or replaces an
 // existing file that has the same name. Note that
 // the file name cannot contain path separators.
 final String FILE_NAME = "sensistive_info.txt";
 String fileContents = "This is some top-secret information!";
 
 FileOutputStream fos = openFileOutput(FILE_NAME, Context.MODE_PRIVATE);
 fos.write(fileContents.getBytes());
 fos.close();

\end{lstlisting}

\emph{The following code snippet shows the inverse operation, reading data from storage:}
\begin{lstlisting}[language=Java, caption=Read data from the internal storage, numbers=none]
 // The file name cannot contain path separators.
 final String FILE_NAME = "sensitive_info.txt";
 FileInputStream fis = openFileInput(FILE_NAME);
 
 // available() determines the approximate number of
 // bytes that can be read without blocking.
 int bytesAvailable = fis.available();
 StringBuilder topSecretFileContents = new StringBuilder(bytesAvailable);
 
 // Make sure that read() returns a number of bytes
 // that is equal to the file's size.
 byte[] fileBuffer = new byte[bytesAvailable];
 while (fis.read(fileBuffer) != -1) {
   topSecretFileContents.append(fileBuffer);
 }
\end{lstlisting}

\textbf{Rule design.} The logic of Rule 8 is shown in Algorithm~\ref{algorithm8}.  We check if all output files are opened in private mode. If any output file is opened in a different mode, we consider it a violation to the rule. 

\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{s1} $\leftarrow$ ``openFileOutput''\\
    \texttt{s2} $\leftarrow$ "MODE\textunderscore PRIVATE"\\
    \texttt{methods} $\leftarrow$ getAllCalledMethods()\\
	\ForEach{\upshape \texttt{method} \textbf{in} \texttt{methods}}{
	    \If{\upshape \texttt{method} = \texttt{s1}}{
	        \texttt{mode} $\leftarrow$ getModeArg(\texttt{method})\\
	        \SetAlgoNoLine{\If{\upshape \textbf{not} \texttt{mode} = \texttt{s2}}{
	            \emph{Rule 8 is not respected.}
	        }}
	    }
	}
}
\caption{\change{Store private data within internal storage}}
\label{algorithm8}
\end{algorithm}

\textbf{Attack.} An attacker can read and pollute data since they are not stored in the app private internal storage. Moreover, through a a \textit{Man-in-the-Disk} attack, an attacker can intercept and potentially alter data while they are extracted by an app from the external storage. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 9 - Share data securely across apps} 
\textbf{Google guideline.} \emph{Follow these best practices in order to share your app's content with other apps in a more secure manner:}
\begin{itemize}
	\item \textit{Enforce read-only or write-only permissions as needed.}
	\item \textit{Provide clients one-time access to data by using the} \texttt{FLAG\textunderscore GRANT\textunderscore READ\textunderscore URI\textunderscore PERMISSION} \textit{and} \\ \texttt{FLAG\textunderscore GRANT\textunderscore WRITE\textunderscore URI\textunderscore PERMISSION} \textit{flags.}
	\item \textit{When sharing data, use "content://" URIs, not "file://" URIs. Instances of} \texttt{FileProvider} \textit{do this for you.}
\end{itemize}
\emph{The following code snippet shows how to use URI permission grant flags and content provider permissions to display an app's PDF file in a separate PDF Viewer app:}
\begin{lstlisting}[language=Java, caption=Share data securely across apps, numbers=none]
 // Create an Intent to launch a PDF viewer for a
 // file owned by this app.
 Intent viewPdfIntent = new Intent(Intent.ACTION_VIEW);
 viewPdfIntent.setData(Uri.parse("content://com.example/personal-info.pdf"));

 // This flag gives the started app read access to
 // the file.
 viewPdfIntent.addFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);

 // Make sure that the user has a PDF viewer app
 // installed on their device.
 if (viewPdfIntent.resolveActivity(
   getPackageManager()) != null) {
   startActivity(viewPdfIntent);
 }

\end{lstlisting}

\textbf{Rule design.} The logic of Rule 9 is shown in Algorithm~\ref{algorithm9}. We check if the app passes ``file://'' URIs to other applications using Intents. If this occurs, we consider it a violation to the rule. 

\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{str} $\leftarrow$ ``file:/''\\
    \texttt{arr} $\leftarrow$ [``FLAG\textunderscore GRANT\textunderscore READ\textunderscore URI\textunderscore PERMIS-\\SION'', ``FLAG\textunderscore GRANT\textunderscore WRITE\textunderscore URI\textunderscore PERMIS-\\SION'']\\
	\texttt{setDataIntents} $\leftarrow$ getSetDataIntents()\\
	\ForEach{\upshape \texttt{intent} \textbf{in} \texttt{setDataIntents}} {
	    \texttt{uriScheme} $\leftarrow$ getURIScheme(\texttt{intent})\\
	    \SetAlgoNoLine{\If{\upshape \texttt{uriScheme} = \texttt{str}}{
	        \emph{Rule 9 is not respected.}}   
	    }
	}
}
\caption{\change{Share data securely across apps}}
\label{algorithm9}
\end{algorithm}

\textbf{Attack.} URI permissions can be used to grant other apps access to specific URIs. These permissions are temporary and expire automatically when the receiving app's task stack is finished. 
However, to share a file with another application using a \texttt{file://} URI, the file system permissions need to be changed, allowing anyone to access the file.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 10 - Use scoped directory access} 
\textbf{Google guideline.} \emph{If your app needs to access only a specific directory within the device's external storage, you can use \textit{scoped directory access} to limit your app's access to a device's external storage accordingly. As a convenience to users, your app should save the directory access URI so that users don't need to approve access to the directory every time your app attempts to access it.
\\
\textbf{Note}: if you use scoped directory access with a particular directory in external storage, know that the user might eject the media containing this storage while your app is running. You should include logic to gracefully handle the change to the \texttt{Environment.getExternalStorageState()} return value that this user behaviour causes.
\\
The following code snippet uses scoped directory access with the pictures directory within a device's primary shared storage:}
\begin{lstlisting}[language=Java, caption=Use scoped directory access, numbers=none]
 private static final int PICTURES_DIR_ACCESS_REQUEST_CODE = 42;
 
 private void accessExternalPicturesDirectory() {
   StorageManger sm = (StorageManager) getSystemService(Context.STORAGE_SERVICE);
   StorageVolume = sm.getPrimaryStorageVolume();
   Intent intent = volume.createAccessIntent(Environment.DIRECTORY_PICTURES);
   startActivityForResult(intent, PICTURES_DIR_ACCESS_REQUEST_CODE);
 }
 
 ...
 
 @Override
 public void onActivityResult(int requestCode, int resultCode, Intent resultData) {
   if (requestCode==PICTURES_DIR_ACCESS_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
   
     // User approved access to scoped directory in
     // your app
     if (resultData != null) {
       Uri picturesDirUri = resultData.getData();
       
       // Save user's approval for accessing this
       // directory in your app
       ContentResolver myContentResolver = getContentResolver();
       myContentResolver.takePersistableUriPermission(picturesDirUri, Intent.FLAG_GRANT_READ_URI_PERMISSION);
     }
   }
 }
\end{lstlisting}

\emph{\textbf{Warning}: don't pass null into \texttt{createAccessIntent()} unnecessarily because this grants your app access to the entire volume that \texttt{StorageManager} finds for your app.}

\textbf{Rule design.} The logic of Rule 10 is shown in Algorithm~\ref{algorithm10}. We check if the app requests external storage permissions. If it does, we consider it a violation to the rule.

\setcounter{algocf}{9}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{arr} $\leftarrow$ [``READ\textunderscore EXTERNAL\textunderscore STORAGE'', ``WRITE\textunderscore EXTERNAL\textunderscore STORAGE'']\\
	\texttt{permissions} $\leftarrow$ getAllPermissions()\\
	\ForEach{\upshape \texttt{perm} \textbf{in} \texttt{permissions}}{
	    \SetAlgoNoLine\If{\upshape \texttt{perm} \textbf{in} \texttt{arr}}{
			   \emph{Rule 10 is not respected.}
	    }}
}
\caption{Use scoped directory access}
\label{algorithm10}
\end{algorithm}

\textbf{Attack.} As for Rule 3, according to which an app should declare the minimum number of permissions, Rule 10 aims to prevent any malicious code running within the same UID of the app from having access to the whole external storage. Thus, if Rule 10 is not respected and the app has access to the external storage, any malicious code running inside it can not only compromise the app files, but also the ones belonging to other apps. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 11 - Store only non-sensitive data in cache files} 

\textbf{Google Guideline.} \emph{To provide quicker access to non-sensitive app data, store it in the device's cache. For caches larger than 1 MB in size, use \texttt{getExternalCacheDir()}; otherwise, use \texttt{getCacheDir()}. Each method provides you with the \texttt{File} object that contains your app's cached data.
\\
The following code snippet shows how to cache a file that your app recently downloaded:}
\begin{lstlisting}[language=Java, caption=Store only non-sensitive data in cache files, numbers=none]
 File cacheDir = getCacheDir();
 File fileToCache = new File(myDownloadedFileUri);
 String fileToCacheName = fileToCache.getName();
 File cacheFile = new File(cacheDir.getPath(), fileToCacheName);
\end{lstlisting}

\emph{\textbf{Note}: if you use \texttt{getExternalCacheDir()} to place your app's cache within shared storage, the user might eject the media containing this storage while your app is running. You should include logic to gracefully handle the cache miss that this user behavior causes.
\\
\textbf{Caution}: there is no security enforced on these files. Therefore, any app that has the \texttt{WRITE\textunderscore EXTERNAL\textunderscore STORAGE} permission can access the contents of this cache.}

\textbf{Rule design.} The logic of Rule 11 is shown in Algorithm~\ref{algorithm11}. We check if the app calls the \texttt{getExternalCacheDir} method, and if it does, we show a warning that reminds the developer that sensitive data should not be saved in the device external cache. 

\setcounter{algocf}{10}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{s1} $\leftarrow$ ``getExternalCacheDir''\\
	\texttt{methods} $\leftarrow$ getAllCalledMethods()\\
	    \SetAlgoNoLine{\If{\upshape \texttt{s1} \textbf{in} \texttt{methods}}{
	        \emph{Rule 11 is not respected.}
	    }}
}
\caption{Store only non-sensitive data in cache files}
\label{algorithm11}
\end{algorithm}

\textbf{Attack.} A malicious app can access any data saved in the device external cache, including sensitive data. The directory returned by \texttt{getExternalCacheDir()} is an external storage directory accessible by any other app on the same device.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 12 - Use SharedPreferences in private mode} 
\textbf{Google guideline.} \emph{When using creating or accessing your app's \texttt{SharedPreferences} objects, use \texttt{MODE\textunderscore PRIVATE}. That way, only your app can access the information within the shared preferences file.}
\\
\textit{If you want to share data across apps, don't use \texttt{Shared-\allowbreak Preferences} objects. Instead, you should follow the necessary steps to share data securely across apps.}

\textbf{Rule design.} The logic of Rule 12 is shown in Algorithm~\ref{algorithm12}. We get the list of \texttt{SharedPreferences} objects opened by the app, and verify that they are opened in private mode. If any of the SharedPreferences objects is opened in a different mode, we consider it a violation to the rule.

\setcounter{algocf}{11}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{s1} $\leftarrow$ [``getSharedPreferences'', ``getPreferences'']\\
    \texttt{s2} $\leftarrow$ "MODE\textunderscore PRIVATE"\\
    \texttt{methods} $\leftarrow$ getAllCalledMethods()\\
	\ForEach{\upshape \texttt{method} \textbf{in} \texttt{methods}}{
	    \If{\upshape \texttt{method} \textbf{in} \texttt{s1}}{
	        \texttt{mode} $\leftarrow$ getModeArg(\texttt{method})\\
	        \SetAlgoNoLine{\If{\upshape \textbf{not} \texttt{mode} = \texttt{s2}}{
	            \emph{Rule 12 is not respected.}
	        }}
	    }
	}
}
\caption{\change{Use SharedPreferences in private mode}}
\label{algorithm12}
\end{algorithm}

\textbf{Attack.} If an app accesses to its \texttt{SharedPreferences} without the \texttt{MODE\textunderscore PRIVATE}, a malicious app on the same device can access the same and read/modify the stored information.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 13 - Keep services and dependencies up-to-date} 
\textbf{Google guideline.} \emph{Most apps use external libraries and device system information to complete specialized tasks. By keeping your app's dependencies up to date, you make these points of communication more secure.}

\subsubsection{Check the Google Play services security provider}
\emph{\textbf{Note}: this section applies only to apps targeting devices that have \textit{Google Play services} installed.
\\
If your app uses Google Play services, make sure that it's updated on the device where your app is installed. This check should be done asynchronously, off of the UI thread. If the device isn't up-to-date, your app should trigger an authorization error.
\\
To determine whether Google Play services is up to date on the device where your app is installed, follow the steps in the guide for "Updating Your Security Provider to Protect Against SSL Exploits"\footnote{https://developer.android.com/training/articles/security-gms-provider}.}

\textbf{Rule design.} The logic of Rule 13 is shown in Algorithm~\ref{algorithm13}. We check if the app ensures that the last version of Google Play Services is installed. If this is not the case, we consider it a violation to the rule.

\setcounter{algocf}{12}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{s1} $\leftarrow$ ``ProviderInstaller.installIfNeeded''\\
    \texttt{s2} $\leftarrow$ ``ProviderInstaller.installIfNeededAsync''\\
	\If{\upshape appUsesPlayServices()}{
	    \texttt{respected} $\leftarrow$ False\\
	    \texttt{javaCode} $\leftarrow$ getAllJavaCode()\\
	    \ForEach{\upshape \texttt{word} \textbf{in} \texttt{javaCode}}{
	        \If{\upshape \texttt{word} \textbf{in} [s1, s2]}{
	            \texttt{respected} $\leftarrow$ True
	        }
	    }
	   \SetAlgoNoLine{
		\If{\upshape \textbf{not} \texttt{respected}}{
			    \emph{Rule 13 is not respected.}
			}	
	}
	}
}
\caption{\change{Keep services and dependencies up-to-date}}
\label{algorithm13}
\end{algorithm}

\textbf{Attack.} Not keeping Google Play services or third-party libraries up-to-date would let an Android application vulnerable to some known vulnerabilities. An attacker might exploit these vulnerabilities, which have been already identified and published.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 14 - Check validity of external storage data} 
\textbf{Google guideline.} \emph{If your app uses data from external storage, make sure that the contents of the data haven't been corrupted or modified. Your app should also include logic to handle files that are no longer in a stable format.
\\
An example of a hash verifier appears in the following code snippet:}
\begin{lstlisting}[language=Java, caption=Check validity of data, numbers=none]
 Executor threadPoolExecutor = Executors.newFixedThreadPool(4);
 private interface HashCallback {
   void onHashCalculated(@Nullable String hash);
 }

 boolean hashRunning = calculateHash(inputStream, threadPoolExecutor, hash -> {
   if (Objects.equals(hash, expectedHash)) {
     // Work with the content.
   }
 });

 if (!hashRunning) {
   // There was an error setting up the hash
   // function.
 }

 private boolean calculateHash(@NonNull InputStream stream, @NonNull Executor executor, @NonNull HashCallback hashCallback) {
   final MessageDigest digest;
   try {
     digest = MessageDigest.getInstance("SHA-512");
   } catch (NoSuchAlgorithmException nsa) {
     return false;
   }

   // Calculating the hash code can take quite a bit
   // of time, so it shouldn't be done on the main
   // thread.
   executor.execute(() -> {
     String hash;
     try (DigestInputStream digestStream =
       new DigestInputStream(stream, digest)) {
         while (digestStream.read() != -1) {
           // The DigestInputStream does the work;
           // nothing for us to do.
         }
         StringBuilder builder=new StringBuilder();
         for (byte aByte : digest.digest()) {
           builder.append(String.format("%02x", aByte)).append(':');
         }
         hash = builder.substring(0,
         builder.length() - 1);
     } catch (IOException e) {
       hash = null;
     }

     final String calculatedHash = hash;
     runOnUiThread(() -> hashCallback.onHashCalculated(calculatedHash));
   });
   return true;
 }

\end{lstlisting}

\textbf{Rule design.} The logic of Rule 14 is shown in Algorithm~\ref{algorithm14}. We check if the app reads any file from the external storage. If this is so, we show a warning stating that the app should check the validity of the data read from those files. 

\setcounter{algocf}{13}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{str} $\leftarrow$ ``READ\textunderscore EXTERNAL\textunderscore STORAGE''\\
	\texttt{permissions} $\leftarrow$ getAllPermissions()\\
{
	    \If{\upshape \texttt{str} \textbf{in} \texttt{permissions}}{
	        \texttt{vars} $\leftarrow$ getAllFileInputVars()\\
	    \ForEach{\upshape \texttt{var} \textbf{in} \texttt{vars}}{
	        \SetAlgoNoLine{\If{\upshape isExternalStorageDir(\texttt{var})}{
	                \emph{Rule 14 is not respected.}
	            }}
	    }
	    }
	}
}
\caption{\change{Check validity of data}}
\label{algorithm14}
\end{algorithm}

\textbf{Attack.} If an app does not check the validity of the data stored on the external storage, it might not rely that some data could have been tampered with by a malicious app on the same device.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 15 - Do not create Dangerous permissions} 

\textbf{Google guideline.} \emph{Generally, you should strive to define as few permissions as possible while satisfying your security requirements. Creating a new permission is relatively uncommon for most applications, because the \textit{system-defined permissions} cover many situations. Where appropriate, perform access checks using existing permissions.}

\emph{If you must create a new permission, consider whether you can accomplish your task with a \textit{signature protection level}. Signature permissions are transparent to the user and allow access only by applications signed by the same developer as the application performing the permission check. If the new permission is still required, it's declared in the app manifest using the \texttt{<permission>} element. Apps that wish to use the new permission can reference it by each adding a \texttt{<uses-permission>} element in their respective manifest files. You can also add permissions dynamically by using the \texttt{addPermission()} method.}

\emph{If you create a permission with the \textit{dangerous protection level}, there are a number of complexities that you need to consider:
\begin{itemize}
	\item The permission must have a string that concisely expresses to a user the security decision they are required to make.
	\item The permission string must be localized to many different languages.
	\item Users may choose not to install an application because a permission is confusing or perceived as risky.
	\item Applications may request the permission when the creator of the permission has not been installed.
\end{itemize}}

\emph{Each of these poses a significant nontechnical challenge for you as the developer while also confusing your users, which is why we discourages the use of the dangerous permission level.}

\textbf{Rule design.} The logic of Rule 15 is shown in Algorithm~\ref{algorithm15}. We collect the list of custom permissions declared in the manifest. If any of these permissions is declared as dangerous, we consider it a violation to the rule. 

\setcounter{algocf}{14}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{str} $\leftarrow$ ``dangerous''\\
	\texttt{permissions} $\leftarrow$ getCustomPermissions()\\
	\ForEach{\upshape \texttt{perm} \textbf{in} \texttt{permissions}}{
	    \SetAlgoNoLine{\If{\upshape getPermProtectLevel(\texttt{perm}) = \texttt{str}}{
	        \emph{Rule 15 is not respected.}
	    }}
	}
}
\caption{\change{Create permissions}}
\label{algorithm15}
\end{algorithm}

\textbf{Attack.} Defining new permissions without the signature protection level might lead to a lack of access control to protected resources. Any malicious app can declare the new permission and exploit it, since no control over the signature will be applied.  

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 16 - Erase data in WebView cache} 

\textbf{Google Guideline.} 
\emph{If your application accesses sensitive data with a \texttt{WebView}, you may want to use the \texttt{clearCache()} method to delete any files stored locally. You can also use server-side headers such as \texttt{no-cache} to indicate that an application should not cache particular content.}

\textbf{Rule design.} The logic of Rule 16 is shown in Algorithm~\ref{algorithm16}. We check if the app clears the cache of all the WebView object it uses. 

\setcounter{algocf}{15}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{webViews} $\leftarrow$ getAllWebViewVars()\\
	\ForEach{\upshape \texttt{webView} \textbf{in} \texttt{webViews}}{
        \SetAlgoNoLine{\If{\upshape \textbf{not} usesClearCache(\texttt{webView})}{
        \emph{Rule 16 is not respected.}
    }}
	}
}
\caption{\change{Erase data in webview cache}}
\label{algorithm16}
\end{algorithm}

\textbf{Attack.} If an app using a \texttt{WebView} object and does not clear its cache through the \texttt{clearCache()} method, any malicious code running within the app UID (e.g., third-party libraries) can access to the data saved in the cache. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 17 - Avoid SQL injections} 

\textbf{Google Guideline.} 
\emph{When accessing a content provider, use parameterized query methods such as \texttt{query()}, \texttt{update()}, and \texttt{delete()} to avoid potential SQL injection from untrusted sources. Note that using parameterized methods is not sufficient if the \texttt{selection} argument is built by concatenating user data prior to submitting it to the method.
\\
Don't have a false sense of security about the write permission. The write permission allows SQL statements that make it possible for some data to be confirmed using creative \texttt{WHERE} clauses and parsing the results. For example, an attacker might probe for the presence of a specific phone number in a call log by modifying a row only if that phone number already exists. If the content provider data has predictable structure, the write permission may be equivalent to providing both reading and writing.}

\textbf{Rule design.} The logic of Rule 17 is shown in Algorithm~\ref{algorithm17}. If the \texttt{query()} method of a Content Provider is overridden, the user input should be properly validated to avoid SQL injections. For this reason, we check if the app contains Content Providers that redefine the \texttt{query()} method, and if it does, we show a warning reminding the user that the input should be properly validated. 

\setcounter{algocf}{16}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{str} $\leftarrow$ ``query''\\
	\texttt{extendCP} $\leftarrow$ getClassesExtendCP()\\
	\ForEach{\upshape \texttt{obj} \textbf{in} \texttt{extendCP}}{
	    \texttt{methods} $\leftarrow$ getObjMethods(\texttt{obj})\\
	    \ForEach{\upshape \texttt{method} \textbf{in} \texttt{methods}}{
	        \SetAlgoNoLine{\If{\upshape \texttt{method} = \texttt{str} }{
	    \emph{Rule 17 is not respected.}
	        }}
	    }
	}
}
\caption{\change{Avoid SQL injections: use content providers}}
\label{algorithm17}
\end{algorithm}

\textbf{Attack.} If an app uses parameterized query methods to access one of its content providers, but the selection argument is built by concatenating user data, an attacker can launch SQL injection attacks. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 18 - Prefer explicit intents} 
\textbf{Google Guideline.} \emph{For activities and broadcast receivers, intents are the preferred mechanism for asynchronous IPC in Android. Depending on your application requirements, you might use \texttt{sendBroadcast()}, \texttt{sendOrderedBroadcast()}, or an explicit intent to a specific application component. For security purposes, explicit intents are preferred.
\\
\textbf{Caution}: if you use an intent to bind to a \texttt{Service}, ensure that your app is secure by using an \textit{explicit} intent. Using an implicit intent to start a service is a security hazard because you can't be certain what service will respond to the intent, and the user can't see which service starts. Beginning with Android 5.0 (API level 21), the system throws an exception if you call \texttt{bindService()} with an implicit intent.
\\
Note that ordered broadcasts can be \textit{consumed} by a recipient, so they may not be delivered to all applications. If you are sending an intent that must be delivered to a specific receiver, you must use an explicit intent that declares the receiver by name.
\\
Senders of an intent can verify that the recipient has permission by specifying a non-null permission with the method call. Only applications with that permission receive the intent. If data within a broadcast intent may be sensitive, you should consider applying a permission to make sure that malicious applications can't register to receive those messages without appropriate permissions. In those circumstances, you may also consider invoking the receiver directly, rather than raising a broadcast.}

\textbf{Rule design.} The logic of Rule 18 is shown in Algorithm~\ref{algorithm18}. 
We check all the intents the app uses to send broadcast messages, start or bind services, or start activities. If any of these intents is implicit, we consider it a violation to the rule. 

\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{bindNames} $\leftarrow$ getBindNamesIntents()\\
	\texttt{startService} $\leftarrow$ getStartServiceIntents()\\
	\texttt{sendOrdBcast} $\leftarrow$ getSendOrdBcastIntents()\\
	\texttt{startActivity} $\leftarrow$ getStartActivityIntents()\\
	\texttt{intents} $\leftarrow$ \texttt{bindNames} + \texttt{startService} + \texttt{sendOrdBcast} + \texttt{startActivity}\\
	\ForEach{\upshape \texttt{intent} \textbf{in} \texttt{intents}}{
	    \SetAlgoNoLine{\If{\upshape \textbf{not} isExplicit(\texttt{intent})}{
	        \emph{Rule 18 is not respected.}
	    }}
	}
}
\caption{\change{Prefer explicit intents}}
\label{algorithm18}
\end{algorithm}

\textbf{Attack.} The attack is the same as for Rule 1. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 19 - Do not use IP networking for IPC} 
\textbf{Google guideline.} 
\emph{Some applications use \textit{localhost} network ports for handling sensitive IPC. You should not use this approach because these interfaces are accessible by other applications on the device. Instead, use an Android IPC mechanism where authentication is possible, such as with a \texttt{Service}. Binding to \texttt{INADDR\textunderscore ANY} is worse than using loopback because then your application may receive requests from anywhere.}

\textbf{Rule design.} The logic of Rule 19 is shown in Algorithm~\ref{algorithm19}. We look for reference to local addresses (e.g. ``localhost'') in the code of the app. If we find any, we consider it a violation to the rule. 

\setcounter{algocf}{18}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{arr} $\leftarrow$ [``INADDR\textunderscore ANY'', ``localhost'', ``127.0.0.1'']\\
    \texttt{javaCode} $\leftarrow$ getAllJavaCode()\\
	\ForEach{\upshape \texttt{word} \textbf{in} \texttt{javaCode}}{
	    \SetAlgoNoLine{\If{\upshape \texttt{word} \textbf{in} \texttt{arr}}{
	        \emph{Rule 19 is not respected.}
	    }
	  }
	}
}
\caption{Use IP networking}
\label{algorithm19}
\end{algorithm}

\textbf{Attack.} A malicious app can connect to the same localhost network ports as legitimate apps and intercept the messages they exchange. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 20 - Do not export unprotected services} 
\textbf{Google guideline.} \emph{A \texttt{Service} is often used to supply functionality for other applications to use. Each service class must have a corresponding \texttt{<service>} declaration in its manifest file.
\\
By default, services are not exported and cannot be invoked by any other application. However, if you add any intent filters to the service declaration, it is exported by default. It's best if you explicitly declare the \texttt{android:exported} attribute to be sure it behaves as you'd like. Services can also be protected using the \texttt{android:permission} attribute. By doing so, other applications need to declare a corresponding \texttt{<uses-permission>} element in their own manifest to be able to start, stop, or bind to the service. 
\\
A service can protect individual IPC calls into it with permissions, by calling \texttt{checkCallingPermission()} before executing the implementation of that call. You should use the declarative permissions in the manifest, since those are less prone to oversight.
\\
\textbf{Caution}: don't confuse client and server permissions; ensure that the called app has appropriate permissions and verify that you grant the same permissions to the calling app.}

\textbf{Rule design.} The logic of Rule 20 is shown in Algorithm~\ref{algorithm20}. We look at the services that an app exports. If the app contains any implicitly exported service, or if any of the exported services does not check for permissions, we consider it a violation to the rule. 

\setcounter{algocf}{19}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{services} $\leftarrow$ getAllServices()\\
	\ForEach{\upshape \texttt{svc} \textbf{in} \texttt{services}}{
	    \SetAlgoNoLine\If{\upshape hasIntentFilter(\texttt{svc})\\ \textbf{and not} isExported(\texttt{svc})}{
            \emph{Rule 20 is not respected.}
	    }
	    \If{\upshape isExported(\texttt{svc})}{
	        \SetAlgoNoLine{\If{\upshape \textbf{not} hasPerm(\texttt{svc}) \\ \textbf{and not} checksCallingPerm(\texttt{svc})}{
	        \emph{Rule 20 is not respected.}
	        }}
	    }
    }
}
\caption{\change{Use services}}
\label{algorithm20}
\end{algorithm}

\textbf{Attack.} If a \texttt{Service} is \emph{exported}, a malicious app can interact with it by sending malicious \texttt{Intent} messages, that compromise the \texttt{Service} runtime execution.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 21 - Do not use telephony networking for sensitive data} 
\textbf{Google guideline.} \emph{The SMS protocol was primarily designed for user-to-user communication and is not well-suited for apps that want to transfer data. Due to the limitations of SMS, you should use \textit{Google Cloud Messaging} (GCM) and IP networking for sending data messages from a web server to your app on a user device.
\\
Beware that SMS is neither encrypted nor strongly authenticated on either the network or the device. In particular, any SMS receiver should expect that a malicious user may have sent the SMS to your application. Don't rely on unauthenticated SMS data to perform sensitive commands. Also, you should be aware that SMS may be subject to spoofing and/or interception on the network. On the Android-powered device itself, SMS messages are transmitted as broadcast intents, so they may be read or captured by other applications that have the \texttt{READ\textunderscore SMS} permission.}

\textbf{Rule design.} The logic of Rule 21 is shown in Algorithm~\ref{algorithm21}. Since an app may use SMS for legitimate reasons, we check the manifest of the app and look for SMS-related permissions. If we find any, we remind the user that SMS are inherently insecure and should not be trusted or used to send sensitive information. 
 
 \setcounter{algocf}{20}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{arr} $\leftarrow$ [``SEND\textunderscore SMS'', ``READ\textunderscore SMS'', ``RECEIVE\textunderscore SMS'']\\
	\texttt{permissions} $\leftarrow$ getAllPermissions()\\
	\ForEach{\upshape \texttt{perm} \textbf{in} \texttt{permissions}}{
	    \SetAlgoNoLine{\uIf{\upshape \texttt{perm} \textbf{in} \texttt{arr}}{
	        \emph{Rule 21 is not respected.}
	    }
	  }
	}
}
\caption{Use telephony networking}
\label{algorithm21}
\end{algorithm}

\textbf{Attack.} An attacker could use \textit{sms spoofing} to send a malicious SMS to a legitimate app. Alternatively, an attacker could intercept the SMS messages sent by a legitimate app and read their content, which is not encrypted.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 22 - Use secure random number generators for cryptographic keys} 
\textbf{Google guideline.} 
\emph{Use a secure random number generator, \texttt{SecureRandom}, to initialize any cryptographic keys generated by \texttt{KeyGenerator}. Use of a key that is not generated with a secure random number generator significantly weakens the strength of the algorithm and may allow offline attacks.
\\
If you need to store a key for repeated use, use a mechanism, such as \texttt{KeyStore}, that provides a mechanism for long term storage and retrieval of cryptographic keys.}

\textbf{Rule design.} The logic of Rule 22 is shown in Algorithm~\ref{algorithm22}. We look for KeyGenerator objects in the code of the app. If any of these objects is non initialized using a secure random number generator, we cosider it a violation to the rule. 

\setcounter{algocf}{21}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{keyGens} $\leftarrow$ getAllKeyGenVars()\\
    \texttt{secRands} $\leftarrow$ getAllSecRandVars()\\
	\ForEach{\upshape \texttt{keyGen} \textbf{in} \texttt{keyGens}}{
	    \SetAlgoNoLine{\If{\upshape \textbf{not} initsWithAny(\texttt{keyGen}, \texttt{secRands})}{
	           \emph{Rule 22 is not respected.}
	    }}
	}
}
\caption{\change{Use cryptography}}
\label{algorithm22}
\end{algorithm}

\textbf{Attack.} When keys are not generated through secure random number generators, a malicious app can infer the value of such keys and decrypt any sensitive data previously encrypted by the legitimate app. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Rule 23 - Protect exported Broadcast Receivers} 

\textbf{Google Guideline.} \emph{A \texttt{BroadcastReceiver} handles asynchronous requests initiated by an \texttt{Intent}.
\\
By default, receivers are exported and can be invoked by any other application. If your \texttt{BroadcastReceiver} is intended for use by other applications, you may want to apply security permissions to receivers using the \texttt{<receiver>} element within the application manifest. This prevents applications without appropriate permissions from sending an intent to the \texttt{BroadcastReceiver}.}

\textbf{Rule design.} The logic of Rule 23 is shown in Algorithm~\ref{algorithm23}. We inspect all Broadcast Receivers declared by the app. If there is any Broadcast Receiver that is not protected by a permission, we consider it a violation to the rule. 

\setcounter{algocf}{22}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{receivers} $\leftarrow$ getAllBcastReceivers()\\
	\ForEach{\upshape \texttt{receiver} \textbf{in} \texttt{receivers}}{
	    \If{\upshape isExported(\texttt{receiver})}{
     	   \SetAlgoNoLine{\If{\upshape \textbf{not} hasPermission(\texttt{receiver})}{
     	       \emph{Rule 23 is not respected.}
     	   }}
     	}
	}
}
\caption{\change{Use broadcast receivers}}
\label{algorithm23}
\end{algorithm}

\textbf{Attack.} Any malicious app can create an intent which can trigger an exported receiver not protected by a permission. For instance, let's consider an exported and not protected receiver which sends an SMS to a phone number received as an extra parameter of the triggering intent. A malicious application could trigger the receiver by sending intents with a premium rate SMS number. Thus, it would force users to send messages without their consent, stealing money from them. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Rule 24 - Do not load code dynamically} 
\textbf{Google guideline.} \emph{We strongly discourage loading code from outside of your application APK. Doing so significantly increases the likelihood of application compromise due to code injection or code tampering. It also adds complexity around version management and application testing. It can also make it impossible to verify the behavior of an application, so it may be prohibited in some environments.
\\
If your application does dynamically load code, the most important thing to keep in mind about dynamically-loaded code is that it runs with the same security permissions as the application APK. The user makes a decision to install your application based on your identity, and the user expects that you provide any code run within the application, including code that is dynamically loaded.
\\
The major security risk associated with dynamically loading code is that the code needs to come from a verifiable source. If the modules are included directly within your APK, they cannot be modified by other applications. This is true whether the code is a native library or a class being loaded using \texttt{DexClassLoader}. Many applications attempt to load code from insecure locations, such as downloaded from the network over unencrypted protocols or from world-writable locations such as external storage. These locations could allow someone on the network to modify the content in transit or another application on a user's device to modify the content on the device.}

\textbf{Rule design.} The logic of Rule 24 is shown in Algorithm~\ref{algorithm24}. We search for any invocation to the \texttt{DexClassLoader} class and consider it a violation to the rule. 

\setcounter{algocf}{23}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{str} $\leftarrow$ ``DexClassLoader''\\
    \texttt{javaCode} $\leftarrow$ getAllJavaCode()\\
	\ForEach{\upshape \texttt{word} \textbf{in} \texttt{javaCode}}{
	    \SetAlgoNoLine{\If{\upshape \texttt{word} = \texttt{str}}{
	        \emph{Rule 24 is not respected.}
	    }}
	}
}
\caption{Dynamically load code}
\label{algorithm24}
\end{algorithm}

\textbf{Attack.} A malicious app can launch a code injection attack through which it modifies the code that a legitimate app will dynamically load. This aim can be achieved if the code is saved in the external storage, is downloaded from a remote location (and, thus, intercepted and modified). 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 25 - Do not disable hostname verification}

\textbf{Google guideline.} \emph{\textbf{Caution}: Replacing \texttt{HostnameVerifier} can be \textit{very dangerous} if the other virtual host is not under your control, because a man-in-the-middle attack could direct traffic to another server without your knowledge.
\\
If you are still sure you want to override hostname verification, here is an example that replaces the verifier for a single \texttt{URLConnection} with one that still verifies that the hostname is at least on expected by the app:}
\begin{lstlisting}[language=Java, caption= problems with hostname verification, numbers=none]
 // Create an HostnameVerifier that hardwires the
 // expected hostname. Note that is different than
 // the URL's hostname: example.com versus
 // example.org
 HostnameVerifier verifier = new HostnameVerifier(){
   @Override
   public boolean verify(String hostname, SSLSession session) {
     HostnameVerifier hv=HttpsURLConnection.getDefaultHostnameVerifier();
     return hv.verify("example.com", session);
   }
 };

 // Tell the URLConnection to use our
 // HostnameVerifier
 URL url = new URL("https://example.org/");
 HttpsURLConnection urlConnection =
   (HttpsURLConnection)url.openConnection();
 urlConnection.setHostnameVerifier(verifier);
 InputStream in = urlConnection.getInputStream();
 copyInputStreamToOutputStream(in, System.out);

\end{lstlisting}

\textbf{Rule design.} The logic of Rule 25 is shown in Algorithm~\ref{algorithm25}. We look for HttpsUrlConnection objects used by the app. If any of them overrides the default hostname verifier, we consider it a violation to the rule. 

\setcounter{algocf}{24}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{connections} $\leftarrow$ getAllHttpsUrlConnections()\\
	\ForEach{\upshape \texttt{connection} \textbf{in} \texttt{connections}}{
	    \SetAlgoNoLine{\If{\upshape hasSetHostnameVerifier(\texttt{connection})}{
	        \emph{Rule 25 is not respected.}
	    }}
	}
}
\caption{\change{Common problems with hostname verification}}
\label{algorithm25}
\end{algorithm}

\textbf{Attack.} A malicious app can perform a man-in-the-middle attack by redirecting the traffic, originally sent to a legitimate server, towards another malicious one. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 26 - Do hostname verification when using SSLSocket}

\textbf{Google guideline.} 
\emph{\textbf{Caution}: \texttt{SSLSocket} does not perform hostname verification. It is up to your app to do its own hostname verification, preferably by calling \texttt{getDefaultHostnameVerifier()} with the expected hostname. Further beware that \texttt{HostnameVerifier.verify()} doesn't throw an exception on error but instead returns a boolean result that you must explicitly check. 
\\
Here is an example showing how you can do this. It shows that when connecting to \textit{gmail.com} port 443 without SNI support, you'll receive a certificate for \textit{mail.google.com}. This is expected in this case, so check to make sure that the certificate is indeed for \textit{mail.google.com}:}
\begin{lstlisting}[language=Java, caption=Warnings about using SSLSocket directly, numbers=none]
 // Open SSLSocket directly to gmail.com
 SocketFactory sf = SSLSocketFactory.getDefault();
 SSLSocket socket = (SSLSocket) sf.createSocket("gmail.com", 443);
 HostnameVerifier hv = HttpsURLConnection.getDefaultHostnameVerifier();
 SSLSession s = socket.getSession();

 // Verify that the certicate hostname is for
 // mail.google.com. This is due to lack of SNI
 // support in the current SSLSocket.
 if (!hv.verify("mail.google.com", s)) {
   throw new SSLHandshakeException("Expected mail.google.com, found " + s.getPeerPrincipal());
 }

 // At this point SSLSocket performed certificate
 // verification and we have performed hostname
 // verification, so it is safe to proceed.

 // ... use socket ...
 socket.close();

 \end{lstlisting}
 
\textbf{Rule design.} The logic of Rule 26 is shown in Algorithm~\ref{algorithm26}. We look for SSLSocket objects in the code of the app. If we find any SSL socket object that does not perform hostname verification, we consider it a violation to the rule. 

\setcounter{algocf}{25}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{sslSessions} $\leftarrow$ getAllSslSessions()\\
	\texttt{verifiers} $\leftarrow$ getAllHostnameVerifiers()\\
	\ForEach{\upshape \texttt{ver} \textbf{in} \texttt{verifiers}}{
	    \SetAlgoNoLine{\If{\upshape \textbf{not} verifiesWithAny(\texttt{ver}, \texttt{sslSessions})}{
	        \emph{Rule 26 is not respected.}
	    }}
	}
}
\caption{\change{Warnings about using SSLSocket directly}}
\label{algorithm26}
\end{algorithm}

\textbf{Attack.} A malicious app can launch a man-in-the-middle attack against an app that does not use HTTPS or SSL at all. Moreover, if the victim app does not verify the certificate sent by a server, the attacker can even pretend to the remote server and establish a communication with the victim app. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 27 - Configure CAs for debugging} 
\textbf{Google guideline.} \emph{When debugging an app that connects over HTTPS, you may want to connect to a local development server, which does not have the SSL certificate for your production server. In order to support this without any modification to your app's code, you can specify debug-only CAs, which are trusted only when \texttt{android:debuggable} is true, by using \texttt{debug-overrides}. Normally, IDEs and build tools set this flag automatically for non-release builds.
\\
This is safer than the usual conditional code because, as a security precaution, app stores do not accept apps which are marked debuggable. 
\\
\texttt{res/xml/network\textunderscore security\textunderscore config.xml}:}
\begin{lstlisting}[language=XML_android, caption=Configure CAs for debugging, numbers=none]
 <?xml version="1.0" encoding="utf-8"?>
 <network-security-config>
   <debug-overrides>
     <trust-anchors>
       <certificates src="@raw/debug_cas"/>
     </trust-anchors>
   </debug-overrides>
 </network-security-config>

\end{lstlisting}

\textbf{Rule design.} The logic of Rule 27 is shown in Algorithm~\ref{algorithm27}. We look at the manifest of the app. If the app has debugging enabled, and the network configuration defines a debug override, we show a warning. 

\setcounter{algocf}{26}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{str} $\leftarrow$ ``networkSecurityConfig''\\
    \texttt{element1} $\leftarrow$ ``$<$network-security-config$>$''\\
    \texttt{element2} $\leftarrow$ ``$<$debug-overrides$>$''\\
	\texttt{app} $\leftarrow$ getManifestApplicationElement()\\
	\texttt{appAttrs} $\leftarrow$ getAttrs(\texttt{app});\\
	\If{\upshape isDebuggableApp()}{
    	\ForEach{\upshape \texttt{attr} \textbf{in} \texttt{appAttrs}}{
    	    \If{\upshape \texttt{attr} = \texttt{str}}{
    	        \texttt{confEls} $\leftarrow$ getNetSecElements()\\
            	\If{\upshape \texttt{element1} \textbf{in} \texttt{confEls}}{
            	    \If{\upshape \texttt{element2} \textbf{in} \texttt{confEls}}{
            	       \emph{Rule 27 is not respected.}
            	 }
            	 }
    	    }
    	}
	}
}
\caption{\change{Configure CAs for debugging}}
\label{algorithm27}
\end{algorithm}

\textbf{Attack.} Using conditional code to handle connection to a local development server could lead to mistakes in production builds. If developers forget this conditional code, or this conditional code is not well managed, then an attacker could exploit these mistakes and perform a man-in-the-middle attack.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 28 - Do not allow cleartext traffic} 
\textbf{Google guideline.} \emph{\textbf{Note}: the guidance in this section applies only to apps that target Android 8.1 (API level 27) or lower. Starting with Android 9 (API level 28), cleartext support is disabled by default.
\\
Applications intending to connect to destinations using only secure connections can opt-out of supporting cleartext (using the unencrypted HTTP protocol instead of HTTPS) to those destinations. This option helps prevent accidental regressions in apps due to changes in URLs provided by external sources such as backend servers. See \texttt{NetworkSecurityPolicy.isC-\\leartextTrafficPermitted()} for more details.
\\
For example, an app may want to ensure that all connections to \texttt{secure.example.com} are always done over HTTPS to protect sensitive traffic from hostile networks. 
\\
\texttt{res/xml/network\textunderscore security\textunderscore config.xml}:}
\begin{lstlisting}[language=XML_android, caption=Opt out of cleartext traffic, numbers=none]
 <?xml version="1.0" encoding="utf-8"?>
 <network-security-config>
   <domain-config cleartextTrafficPermitted="false">
     <domain includeSubdomains="true">
      secure.example.com
     </domain>
   </domain-config>
 </network-security-config>

\end{lstlisting}

\textbf{Rule design.} The logic of Rule 28 is shown in Algorithm~\ref{algorithm28}. We look at the manifest of the app. If the manifest enables clear-text traffic, we consider it a violation to the rule.

\setcounter{algocf}{27}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{s1} $\leftarrow$ ``networkSecurityConfig''\\
    \texttt{s2} $\leftarrow$ ``cleartextTrafficPermitted''\\
    \texttt{elements} $\leftarrow$ [``$<$domain-config$>$'', ``$<$base-config$>$'']\\
	\texttt{app} $\leftarrow$ getManifestApplicationElement()\\
	\texttt{appAttrs} $\leftarrow$ getAttrs(\texttt{app});\\
	\ForEach{\upshape \texttt{attr} \textbf{in} \texttt{appAttrs}}{
	    \If{\upshape \texttt{attr} = \texttt{s1}}{
	        \texttt{confElements} $\leftarrow$ getNetSecElements()\\
	        \ForEach{\upshape \texttt{element} \textbf{in} \texttt{elements}}
        	{\If{\upshape \texttt{element} \textbf{in} \texttt{confElements}}{
        	    \texttt{dcAttrs} $\leftarrow$ getAttrs(\texttt{element})\\
        	    \ForEach{\upshape \texttt{dcAttr} \textbf{in} \texttt{dcAttrs}}{
        	    \If{\upshape \texttt{dcAttr.name} = \texttt{s2}}{
            	   \SetAlgoNoLine{\If{\upshape \texttt{dcAttr.value}}{
            	   \emph{Rule 28 is not respected.}
            	 }
            	 }}
            	 }
        	 }}
	    }
	}
}
\caption{\change{Opt out of cleartext traffic}}
\label{algorithm28}
\end{algorithm}

\textbf{Attack.} With the \texttt{cleartextTrafficPermitted} flag set to \texttt{true}, any connection using HTTP is allowed. Thus, an attacker can eavesdrop the cleartext content of any communication established by the victim app.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 29 - Choose a recommended cryptographic algorithm} 

\textbf{Google Guideline.} \emph{When you have the freedom to choose which algorithm to use (such as when you do not require compatibility with a third-party system), we recommend using the following algorithms:
\begin{itemize}
	\item \texttt{Cipher} class: AES in CBC or GCM mode with 256-bit keys (such as \texttt{AES}/\texttt{GCM}/\texttt{NoPadding})
	\item \texttt{MessageDigest} class: SHA-2 family (e.g., \texttt{SHA-256})
	\item \texttt{Mac} class: SHA-2 family HMAC (e.g., \texttt{HMACSHA256})
	\item \texttt{Signature} class: SHA-2 family with ECDSA (e.g., \texttt{SHA256withECDSA})
\end{itemize}
} % end of emph

\textbf{Rule design.} The logic of Rule 29 is shown in Algorithm~\ref{algorithm29}. We inspect all the invocations to crypto methods, and verify if they are called with insecure arguments.

\setcounter{algocf}{28}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{cryptoMethods} $\leftarrow$ getAllCryptoMethods()\\
	\ForEach{\upshape \texttt{method} \textbf{in} \texttt{cryptoMethods}}{
	    \SetAlgoNoLine{\If{\upshape \textbf{not} usesRecommendedClassArgs(\texttt{method})}{
	        \emph{Rule 29 is not respected.}
	    }}
	}
}
\caption{\change{Choose a recommended algorithm}}
\label{algorithm29}
\end{algorithm}

\textbf{Attack.} If an app does not properly use cryptographic algorithms or it uses insecure ones, a malicious app can break and access to any data or communication, which should have been protected by cryptography. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 30 - Do not use deprecated cryptographic functionality}
\textbf{Google guideline.} \emph{The following subsections describe deprecated functionality that you should no longer use in your app.}

\subsubsection{Bouncy Castle algorithms}
\emph{A number of algorithms from the "Bouncy Castle provider"\footnote{https://www.bouncycastle.org/} that are also provided by another provider have been depracated in Android P. This only affects cases where the implementation from the Bouncy Castle provider is explicitly requested, such as \texttt{Cipher.getInstance("AES/CBC/PKCS7PADDING",\allowbreak "BC"} or \texttt{Cipher.getInstance("AES/CBC/PKCS7PADD-\allowbreak ING"}, \texttt{Security.getProvider("BC"))}. Requesting a specific provider is discouraged, so if you follow that guideline this deprecation should not affect you. }

\subsubsection{Password-based encryption ciphers without an IV}
\emph{Password-based encryption (PBE) ciphers that require an initialization vector (IV) can obtain it from the key, if it's suitably constructed, or from an explicitly-passed IV. When passing a PBE key that doesn't contain an IV and no explicit IV, the PBE ciphers on Android currently assume an IV of zero.
\\
When using PBE ciphers, always pass an explicit IV, as shown in the following code snippet:}

\begin{lstlisting}[language=Java, caption=Password-based encryption ciphers without an IV, numbers=none]
 SecretKey key = ...;
 Cipher cipher = Cipher.getInstance(
  "PBEWITHSHA256AND256BITAES-CBC-BC");
 byte[] iv = new byte[16];
 new SecureRandom().nextBytes(iv);
 cipher.init(Cipher.ENCRYPT_MODE, key, new IvParameterSpec(iv));

\end{lstlisting}

\textbf{Rule design.} The logic of Rule 30 is shown in Algorithm~\ref{algorithm30}. We look at the code of the app. If the app calls the \texttt{Cipher.getInstance()} method with an explicit provider, or if it uses PBE ciphers without proper initialization, we consider it a violation to the rule. 

\setcounter{algocf}{29}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{ciphers} $\leftarrow$ getAllCipherGetInstance()\\
	\ForEach{\upshape \texttt{cipher} \textbf{in} \texttt{ciphers}}{
	    \SetAlgoNoLine{\If{\upshape hasSecondArgument(\texttt{cipher})}{
	        \emph{Rule 30 is not respected.}
	    }}
	    \SetAlgoLined
	    \If{\upshape hasPBE(\texttt{cipher})}{
	        \SetAlgoNoLine{\If{\upshape \textbf{not} hasInit(\texttt{cipher})}{
	            \emph{Rule 30 is not respected.}
	        }}
	    }
	}
}
\caption{\change{Deprecated cryptographic functionality}}
\label{algorithm30}
\end{algorithm}

\textbf{Attack.} When deprecated and insecure crytographic algorithms are used, a malicious app can decrypt any sensitive data previously encrypted by the legitimate app. 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 31 - Do not migrate private information to device encrypted storage} 
\textbf{Google guideline.} \emph{If a user updates their device to use Direct Boot mode, you might have existing data that needs to get migrated to device encrypted storage. Use \texttt{Context.moveSharedPreferencesFrom()} and \texttt{Context.moveDatabaseFrom()} to migrate preference and database data between credential encrypted storage and device encrypted storage.
\\
Use your best judgment when deciding what data to migrate from credential encrypted storage to device encrypted storage. You should not migrate private user information, such as passwords or authorization tokens, to device encrypted storage. In some scenarios, you might need to manage separate sets of data in the two encrypted stores.}

\textbf{Rule design.} The logic of Rule 31 is shown in Algorithm~\ref{algorithm31}. If the application tries to migrate data to the device encrypted storage, we show a warning to remind the user that private information, such as passwords or authorization tokens, should not be stored in device encrypted storage. 

\setcounter{algocf}{30}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
    \texttt{arr} $\leftarrow$ [``moveSharedPreferencesFrom'', ``moveDatabaseFrom'']\\
	\texttt{methods} $\leftarrow$ getAllCalledMethods()\\
	\ForEach{\upshape \texttt{method} \textbf{in} \texttt{methods}}{
	   \SetAlgoNoLine{ \If{\upshape \texttt{method} \textbf{in} \texttt{arr}}{
	        \emph{Rule 31 is not respected.}
	    }}
	}
}
\caption{Migrate existing data}
\label{algorithm31}
\end{algorithm}

\textbf{Attack.} The device encrypted storage is accessible to apps before the user unlocks the screen of the device for the first time after boot. An attacker could exploit this to get access to sensitive information without needing the user to unlock the device.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Rule 32 - Use device encrypted storage for Direct Boot only} 
\textbf{Google guideline.} \emph{Use device encrypted storage only for information that must be accessible during Direct Boot mode. Do not use device encrypted storage as a general-purpose encrypted store.}

\textbf{Rule design.} The logic of Rule 32 is shown in Algorithm~\ref{algorithm32}. If the application tries to access the device encrypted storage, we show a warning to remind that device encrypted storage should only be used for data that needs to be accessed before the user unlocks the device for the first time. 

\setcounter{algocf}{31}
\begin{algorithm}[]
\SetAlgoLined
\Begin{
	\texttt{methods} $\leftarrow$ getAllCalledMethods()\\
	\texttt{str} $\leftarrow$ ``createDeviceProtectedStorageContext''\\
	\ForEach{\upshape \texttt{method} \textbf{in} \texttt{methods}}{
	   \SetAlgoNoLine{ \If{\upshape \texttt{method} = str}{
	      	\emph{Rule 32 is not respected.}
	    }}
	}
}
\caption{Access device encrypted storage}
\label{algorithm32}
\end{algorithm}

\textbf{Attack.} The device encrypted storage is accessible to apps before the user unlocks the screen of the device for the first time. An attacker could exploit this to get access to sensitive information without needing the user to unlock the device after boot.
\newpage